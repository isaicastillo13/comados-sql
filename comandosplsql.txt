DECLARE 
cadena1 VARCHAR2 (20) := 'Hola mundo';  
fecha_hoy DATE := SYSDATE; 
pi CONSTANT NUMBER := 3.14159265359;  
BEGIN DBMS_OUTPUT.PUT_LINE (cadena1); 
DBMS_OUTPUT.PUT_LINE (fecha_hoy); 
DBMS_OUTPUT.PUT_LINE (pi);  
END; / 

--EJERCICIO 5.2: Asignar valores a variables
DECLARE
cadena VARCHAR2 (20);
fecha_hoy DATE; 
fecha_mañana DATE; 
ultimo_del_mes DATE; 
BEGIN
cadena := 'Hola Isaias'; 
fecha_hoy := SYSDATE; 
fecha_mañana := SYSDATE + 1;
ultimo_del_mes := LAST_DAY(SYSDATE); 
DBMS_OUTPUT.PUT_LINE (cadena);
DBMS_OUTPUT.PUT_LINE (fecha_hoy); 
DBMS_OUTPUT.PUT_LINE (fecha_mañana); 
DBMS_OUTPUT.PUT_LINE (ultimo_del_mes);
 END;
/

--EJERCICIO 5.3: Usar bucles PL/SQL
DECLARE
bucle INTEGER := 2;
BEGIN
LOOP
DBMS_OUTPUT.PUT (bucle || ' ' );
bucle := bucle + 2;
EXIT WHEN bucle = 10;
END LOOP;
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE ( 'Fin del Bucle' );
END;
/

--EJERCICIO 5.3.1: Usar bucles PL/SQL
DECLARE
bucle INTEGER := 0;
BEGIN
WHILE bucle < 10 LOOP
DBMS_OUTPUT.PUT (bucle || ' ');
bucle := bucle + 1;
END LOOP;
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE ('Fin del Bucle.');
 END;
 /

----EJERCICIO 5.3.2: Usar bucles PL/SQL
BEGIN
<<primer_bucle>>
FOR bucle_1 IN 0..25 LOOP --Bucle1
DBMS_OUTPUT.PUT_LINE ('Bucle 1:' || bucle_1);
 DBMS_OUTPUT.PUT ('Bucle 2: ');
<<segundo_bucle>>
FOR bucle_2 IN REVERSE 1..5 LOOP DBMS_OUTPUT.PUT (bucle_2 || ' ');
EXIT segundo_bucle --salida del bucle 2
WHEN ((bucle_1 = 4) AND (bucle_2 = 5));
EXIT primer_bucle --salida del bucle 1
WHEN ((bucle_1 = 7) AND(bucle_2 = 4));
END LOOP segundo_bucle; --fina del bucle 2
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE ('Final del Bucle 2.');
DBMS_OUTPUT.PUT_LINE ('___');
END LOOP primer_bucle; --fin del bucle 1
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE ('Final del Bucle 2.');
END;
/

----EJERCICIO 5.3.1: Usar bucles PL/SQL
BEGIN
FOR i IN 1..20 LOOP
DBMS_OUTPUT.PUT (i || ' ');

IF ((i mod 3 = 0) AND (i mod 5 = 0)) THEN

DBMS_OUTPUT.PUT(':Multipo de 3 y 5');
ELSIF i mod 3 = 0 THEN

DBMS_OUTPUT.PUT(':Multiplo de 3' );
ELSIF i mod 5 = 0 THEN

DBMS_OUTPUT.PUT(':Multiplo de 5'); 
--ELSE
--DBMS_OUTPUT.PUT_LINE (i);
END IF;
DBMS_OUTPUT.PUT_LINE (' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
END;
/

--EJERCICIO 5.5: Usar el comando GOTO de PL/SQL
BEGIN
--set the loop to iterate 10 times
FOR i IN 1..10 LOOP
DBMS_OUTPUT.PUT (i  || ' '); 
IF i = 5 THEN
GOTO messagel;
END IF;
END LOOP;
DBMS_OUTPUT.PUT_LINE('Imprime todas la Iteraciones del Bucle. ');
<<messagel>>
DBMS_OUTPUT.PUT_LINE ('Immpre solo 5 iteraciones (Goto).');
END;

--EJERCICIO 5.6: Manipular datos de tablas con sentencias DML
DECLARE
nuevo_id INTEGER := 6;
descripcion VARCHAR2 (250) := 'Mouse';
BEGIN
INSERT INTO PARTS VALUES (nuevo_id,descripcion, 40, 1200, 500);
END;
/

--EJERCICIO 5.7: Asignar un valor a una variable con una consulta
DECLARE
descripcion VARCHAR2 (250);
BEGIN
SELECT description INTO descripcion
FROM parts
WHERE id = 3;
DBMS_OUTPUT.PUT_LINE('La Parte es: ' || descripcion);
END;
/

--EJERCICIO 5.8: Declarar y usar un procedimiento

DECLARE
--width NUMBER(2,0);

PROCEDURE procedimiento(width IN INTEGER, chr IN CHAR DEFAULT '-' ) IS

BEGIN
FOR i IN 1.. width LOOP
DBMS_OUTPUT.PUT (chr);
END LOOP;

DBMS_OUTPUT.PUT_LINE ('');
END procedimiento;

BEGIN
procedimiento(40,'*');                                                    --imprime una línea con 40 *s 
procedimiento(20,'=');                                                  --imprime una linea con 20 = s
procedimiento(10);                                                       --imprime una linea con 10
END;
/

--EJERCICIO 5.9: Declarar y usar una función

DECLARE
tempTotal NUMBER;
i NUMBER:=1;
FUNCTION funcion (OrderId IN INTEGER) 
RETURN NUMBER--tipo de retorno
IS
precioTotal NUMBER;
tempTotal NUMBER;
i NUMBER;

BEGIN--cuerpo de la funcion
SELECT SUM (items.quantity * parts.unitprice) INTO precioTotal FROM items , parts WHERE items.o_id = orderId AND items.p_id = parts.id GROUP BY items.o_id;

RETURN precioTotal;--variables que tiene el retorno

END funcion;--fin del cuerpo de la funcion

BEGIN--cuerpo del progarma
while i < 6 LOOP
DBMS_OUTPUT.PUT_LINE ('0rder '||i||' Total: '|| funcion (i));
i:=i+1;
END LOOP;

--temptotal := funcion(2);
--DBMS_OUTPUT.PUT_LINE ('Order 2 Total:' || tempTotal);
END;
/

--select items.quantity, parts.unitprice,items.o_id, items.p_id,parts.id   from items , parts where items.o_id = 2 AND items.p_id = parts.id
--EJERCICIO 5.11: Usar el atributo %TYPE
DECLARE
TYPE partRecord IS RECORD (
 Id parts.id%TYPE, 
description parts.description%TYPE, 
unitprice parts.unitprice%TYPE,
 onhand parts.onhand%TYPE, 
reorder parts.reorder%TYPE
);
selectedPart partRecord;
BEGIN
SELECT Id, description, unitprice , onhand, reorder INTO selectedPart 
FROM parts WHERE id = 3;
DBMS_OUTPUT.PUT_LINE('ID:' || selectedPart.id);
DBMS_OUTPUT.PUT_LINE('DESCRIPTION: '|| selectedPart.description);
DBMS_OUTPUT.PUT_LINE('UNIT PRICE: ' || selectedPart.unitprice);
DBMS_OUTPUT.PUT_LINE('CURRENTLY ONHAND: ' || selectedPart.onhand);
DBMS_OUTPUT.PUT_LINE('REORDER AT: '|| selectedPart.reorder);
 END;
/
--EJERCICIO 5.12: Usar el atributo %ROWTYPE
DECLARE
selectedPart parts%ROWTYPE;
BEGIN
SELECT id, description, unitprice , onhand, reorder INTO selectedPart 
FROM parts WHERE id = 3;
DBMS_OUTPUT.PUT_LINE ('ID: '|| selectedPart.id);
DBMS_OUTPUT.PUT_LINE ('DESCRIPTION: '|| selectedPart.description);
DBMS_OUTPUT.PUT_LINE ('UNIT PRICE: '|| selectedPart.unitprice);
DBMS_OUTPUT.PUT_LINE ('CURRENTLY ONHAND: '|| selectedpart.onhand);
DBMS_OUTPUT.PUT_LINE ('REORDER AT: '|| selectedPart.reorder); 
END;

--EJERCICIO 5.13: Declarar y usar un cursor sencillo
DECLARE
    CURSOR c_cursor IS
    SELECT * FROM parts
    ORDER BY id;
    v_producto parts%ROWTYPE; 
BEGIN
    OPEN c_cursor;
        FETCH c_cursor INTO v_producto;
        WHILE c_cursor%FOUND LOOP 
            DBMS_OUTPUT.PUT_LINE (v_producto.id||'    ' ||v_producto.description);
            FETCH c_cursor INTO v_producto;
        END LOOP;
    CLOSE c_cursor;
END;
/

--EJERCICIO 5.14: Usar cursores para iniciar bucles FOR
DECLARE
    CURSOR c_cursor IS
    SELECT * FROM parts
    ORDER BY id;
BEGIN
    FOR v_producto IN c_cursor LOOP
        DBMS_OUTPUT.PUT_LINE(v_producto.id||'   ' ||v_producto.description); 
    END LOOP;
END;
/

DECLARE
    CURSOR c_cursor IS SELECT * FROM parts WHERE id = 1;
BEGIN
    FOR v_producto IN c_cursor LOOP 
        DBMS_OUTPUT.PUT_LINE(v_producto.id || ' - ' || v_producto.description ||' - '||v_producto.unitprice || '$');
    END LOOP;
END;
/

--EJERCICIO 5.15: Declarar cursores con parámetros
DECLARE
    CURSOR c_cursor (v_id INTEGER) IS
    SELECT id,email,phone,firstname || ' ' || lastname AS name FROM customers WHERE s_id = v_id;

BEGIN
    DBMS_OUTPUT.PUT_LINE ('Sales Rep #1 Customers');
    FOR v_cliente IN c_cursor (1)LOOP
        DBMS_OUTPUT.PUT_LINE(' ID: ' || v_cliente.id ||' | Nombre del cliente:  ' || v_cliente.name ||' | Correo electronico: '|| v_cliente.email ||' | Celular: '||v_cliente.phone);
    END LOOP;
END;
/

DECLARE
    CURSOR c_cursor (v_id INTEGER) IS SELECT * FROM customers where id = v_id;
BEGIN
    FOR I IN 1...10 LOOP
        FOR v_cliente IN c_cursor (i) LOOP
            DBMS_OUTPUT.PUT_LINE(i||'). Nombre del Cliente: ' || v_cliente.firstname);
        END LOOP;
    END LOOP;
    
END;
/

--EJERCICIO 5.16: Manipular la fila actual de un cursor
DECLARE
    CURSOR c_cursor (v_id INTEGER) IS SELECT *  FROM parts WHERE ID >= v_id FOR UPDATE;
BEGIN
    FOR producto IN c_cursor (6) LOOP --partes seleccionadas 6 y 7
        DELETE FROM parts
        WHERE CURRENT OF c_cursor;
        DBMS_OUTPUT.PUT_LINE('Parte Eliminada: ' ||  producto.id || ', ' ||producto.description);
    END LOOP;
END;
/

Hola.




